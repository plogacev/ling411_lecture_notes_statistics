[["index.html", "Statistics in R Chapter 1 Initial Remarks", " Statistics in R Pavel Logacev 2020-12-07 Chapter 1 Initial Remarks (07 December, 2020, 22:52) The purpose of these lecture notes is to allow you to revisit concepts covered in class. In the following, I will draw on the following resources. The pretty great introduction to R and statistics by Danielle Navarro available here. Matt Crump’s ‘Answering Questions with Data’. Bodo Winter’s ‘Statistics of Linguists: An Introduction Using R’ "],["scalesOfMeasurement.html", "Chapter 2 Scales of Measurement 2.1 Nominal scale 2.2 Ordinal scale 2.3 Interval scale 2.4 Ratio scale 2.5 Continuous versus discrete variables 2.6 Some complexities", " Chapter 2 Scales of Measurement (an adapted version of Danielle Navarro’s chapter 2.) (07 December, 2020, 22:52) As might recall, the outcome of a measurement is what we call a variable. But not all variables are of the same qualitative type, and it’s very useful to understand what types there are. A very useful concept for distinguishing between different types of variables is what’s known as scales of measurement. 2.1 Nominal scale A nominal scale variable (also referred to as a categorical variable) is one in which there is no particular relationship between the different possibilities. No ordering: For these kinds of variables it doesn’t make any sense to say that one of them is “bigger’ or “better” than any other one, and it doesn’t make any sense to average them. Examples: The classic example for this is “eye color”. Eyes can be blue, green and brown, among other possibilities, but none of them is any “better” than any other one. As a result, it would feel really odd to talk about an “average eye color”. Similarly, gender is nominal too: male isn’t better or worse than female, neither does it make sense to try to talk about an “average gender”. In short, nominal scale variables are those for which the only thing you can say about the different possibilities is that they are different. That’s it. Let’s take a slightly closer look at this. Suppose I was doing research on how people commute to and from work. One variable I would have to measure would be what kind of transportation people use to get to work. This “transport type” variable could have quite a few possible values, including: “train”, “bus”, “car”, “bicycle”, etc. For now, let’s suppose that these four are the only possibilities, and suppose that when I ask 100 people how they got to work today, and I get this: Transportation Number of people (1) Train 12 (2) Bus 30 (3) Car 48 (4) Bicycle 10 So, what’s the average transportation type? Obviously, the answer here is that there isn’t one. It’s a silly question to ask. You can say that travel by car is the most popular method, and travel by train is the least popular method, but that’s about all. 2.2 Ordinal scale Ordinal scale variables have a bit more structure than nominal scale variables, but not by a lot. An ordinal scale variable is one in which there is a natural, meaningful way to order the different possibilities, but you can’t do anything else. Examples: The usual example given of an ordinal variable is “finishing position in a race”. You can say that the person who finished first was faster than the person who finished second, but you don’t know how much faster. As a consequence we know that 1st &lt; 2nd, and we know that 2nd &lt; 3rd, but the difference between 1st and 2nd might be much larger than the difference between 2nd and 3rd. Here’s an more interesting example. Suppose I’m interested in people’s attitudes to climate change, and I ask them to pick one of these four statements that most closely matches their beliefs: Temperatures are rising, because of human activity Temperatures are rising, but we don’t know why Temperatures are rising, but not because of humans Temperatures are not rising These four statements actually do have a natural ordering, in terms of “the extent to which they agree with the current science”. Statement 1 is a close match, Statement 2 is a reasonable match, Statement 3 isn’t a very good match, Statement 4 is in strong opposition to the science. So, in terms of the thing I’m interested in (the extent to which people endorse the science), I can order the items as \\(1 &gt; 2 &gt; 3 &gt; 4\\). So, let’s suppose I asked 100 people these questions, and got the following answers: Response Number (1) Temperatures are rising, because of human activity 51 (2) Temperatures are rising, but we don’t know why 20 (3) Temperatures are rising, but not because of humans 10 (4) Temperatures are not rising 19 When analysing these data, it seems quite reasonable to try to group (1), (2) and (3) together, and say that 81 of 100 people were willing to at least partially endorse the science. And it’s also quite reasonable to group (2), (3) and (4) together and say that 49 of 100 people registered at least some disagreement with the dominant scientific view. However, it would be entirely bizarre to try to group (1), (2) and (4) together and say that 90 of 100 people said what? There’s nothing sensible that allows you to group those responses together at all. 2.3 Interval scale In contrast to nominal and ordinal scale variables, interval scale and ratio scale variables are variables for which the numerical value is genuinely meaningful. In the case of interval scale variables, the differences between the numbers are interpretable, but the variable doesn’t have a “natural” zero value. Examples: A good example of an interval scale variable is measuring temperature in degrees celsius. For instance, if it was 15° yesterday and 18° today, then the 3° difference between the two is genuinely meaningful. Moreover, that 3° difference is exactly the same as the 3° difference between 7° and 10°. In short, addition and subtraction are meaningful for interval scale variables. (Nevermind that a change of 10° will feel different at 20° compared to 30°.) However, notice that the 0° does not mean “no temperature at all”: it actually means “the temperature at which water freezes”, which is pretty arbitrary. As a consequence, it becomes pointless to try to multiply and divide temperatures. It is wrong to say that 20° is twice as hot as 10°, just as it is weird and meaningless to try to claim that 20° is negative two times as hot as 10°. Or suppose I’m interested in looking at how the attitudes of first-year university students have changed over time. Obviously, I’m going to want to record the year in which each student started. This is an interval scale variable. A student who started in 2003 did arrive 5 years before a student who started in 2008. However, it would be completely insane for me to divide 2008 by 2003 and say that the second student started “1.0024 times later” than the first one. That doesn’t make any sense at all. 2.4 Ratio scale The final type of variable to consider is a ratio scale variable, in which zero really means zero, and it’s okay to multiply and divide. Example: A good example of a ratio scale variable is response time (RT). In a lot of tasks it’s very common to record the amount of time somebody takes to solve a problem or answer a question, because it’s an indicator of how difficult the task is. Suppose that Alan takes 2.3 seconds to respond to a question, whereas Ben takes 3.1 seconds. As with an interval scale variable, addition and subtraction are both meaningful here. Ben really did take \\(3.1 - 2.3 = 0.8\\) seconds longer than Alan did. Notice that multiplication and division also make sense here too: Ben took \\(3.1/2.3 = 1.35\\) times as long as Alan did to answer the question. The reason why you can do this is that, for a ratio scale variable such as RT, “zero seconds” really does mean “no time at all”. Scale Meaningful order Meaningful differences Meaningful ratio Nominal scale Ordinal scale x Interval scale x x Ratio scale x x x 2.5 Continuous versus discrete variables There’s a second kind of distinction that you need to be aware of, regarding what types of variables you can run into. This is the distinction between continuous variables and discrete variables. The difference between these is as follows: A continuous variable is one in which, for any two values that you can think of, it’s always logically possible to have another value in between. A discrete variable is, in effect, a variable that isn’t continuous. For a discrete variable, it’s sometimes the case that there’s nothing in the middle. For exampl, response time is continuous. If Alan takes 3.1 seconds and Ben takes 2.3 seconds to respond to a question, then it’s possible for Cameron’s response time to lie in between, by taking 3.0 seconds. And of course it would also be possible for David to take 3.031 seconds to respond, meaning that his RT would lie in between Cameron’s and Alan’s. And while in practice it might be impossible to measure RT that precisely, it’s certainly possible in principle. Because we can always find a new value for RT in between any two other ones, we say that RT is continuous. Discrete variables occur when this rule is violated. For example, nominal scale variables are always discrete: there isn’t a type of transportation that falls “in between” trains and bicycles, not in the strict mathematical way that 2.3 falls in between 2 and 3. So transportation type is discrete. Similarly, ordinal scale variables are always discrete: although “2nd place” does fall between “1st place” and “3rd place”, there’s nothing that can logically fall in between “1st place” and “2nd place”. Interval scale and ratio scale variables can go either way. As we saw above, response time (a ratio scale variable) is continuous. Temperature in degrees celsius (an interval scale variable) is also continuous. However, the year you went to school (an interval scale variable) is discrete. There’s no year in between 2002 and 2003. The number of questions you get right on a true-or-false test (a ratio scale variable) is also discrete: since a true-or-false question doesn’t allow you to be “partially correct”, there’s nothing in between 5/10 and 6/10. 2.6 Some complexities Okay, I know you’re going to be shocked to hear this, but the real world is much messier than this little classification scheme suggests. Very few variables in real life actually fall into these nice neat categories, so you need to be kind of careful not to treat the scales of measurement as if they were hard and fast rules. It doesn’t work like that: they’re guidelines, intended to help you think about the situations in which you should treat different variables differently. Nothing more. So let’s take a classic example, maybe the classic example, of a psychological measurement tool: the Likert scale. The humble Likert scale is the bread and butter tool of all survey design. You yourself have filled out hundreds, maybe thousands of them, and odds are you’ve even used one yourself. Suppose we have a survey question that looks like this: Which of the following best describes your opinion of the statement that “all pirates are freaking awesome” and then the options presented to the participant are these: Strongly disagree Disagree Neither agree nor disagree Agree Strongly agree This set of items is an example of a 5-point Likert scale: people are asked to choose among one of several (in this case 5) clearly ordered possibilities, generally with a verbal descriptor given in each case. However, it’s not necessary that all items be explicitly described. This is a perfectly good example of a 5-point Likert scale too: Strongly disagree Strongly agree Likert scales are very handy, if somewhat limited, tools. The question is, what kind of variable are they? They’re obviously discrete, since you can’t give a response of 2.5. They’re obviously not nominal scale, since the items are ordered; and they’re not ratio scale either, since there’s no natural zero. But are they ordinal scale or interval scale? One argument says that we can’t really prove that the difference between “strongly agree” and “agree” is of the same size as the difference between “agree” and “neither agree nor disagree”. In fact, in everyday life it’s pretty obvious that they’re not the same at all. So this suggests that we ought to treat Likert scales as ordinal variables. On the other hand, in practice most participants do seem to take the whole “on a scale from 1 to 5” part fairly seriously, and they tend to act as if the differences between the five response options were fairly similar to one another. As a consequence, a lot of researchers treat Likert scale data as if it were interval scale. It’s not interval scale, but in practice it’s close enough that we usually think of it as being quasi-interval scale. "],["descriptives.html", "Chapter 3 Descriptive statistics 3.1 Measures of central tendency 3.2 Summary 3.3 Measures of variability", " Chapter 3 Descriptive statistics (an adapted version of Danielle Navarro’s chapter 3/5 on descriptive statistics.) (07 December, 2020, 22:52) Any time that you get a new data set to look at, one of the first tasks that you have to do is find ways of summarising the data in a compact, easily understood fashion. This is what descriptive statistics (as opposed to inferential statistics) is all about. In fact, to many people the term “statistics” is synonymous with descriptive statistics. Before going into any details, let’s take a moment to get a sense of why we need descriptive statistics. To do this, let’s load a dataset on sleep in mammals. #load( &quot;./data_navarro/aflsmall.Rdata&quot; ) #library(lsr) #who() mammalian_sleep &lt;- read.csv(&quot;./data/msleep_ggplot2.csv&quot;) %&gt;% dplyr::select(name, sleep_total, bodywt) %&gt;% dplyr::rename(sleep_total_h = sleep_total, bodywt_kg = bodywt) %&gt;% dplyr::mutate(sleep_total_h = round(sleep_total_h) ) head(mammalian_sleep) ## name sleep_total_h bodywt_kg ## 1 Cheetah 12 50.000 ## 2 Owl monkey 17 0.480 ## 3 Mountain beaver 14 1.350 ## 4 Greater short-tailed shrew 15 0.019 ## 5 Cow 4 600.000 ## 6 Three-toed sloth 14 3.850 There are three variables here, name, sleep_total_h and bodywt_kg. For each animal named in name, the sleep_total_h variable contains the average number of hours animals of this kind sleep per day. The variable bodywt_kg contains the average weight of that animal in kg. Let’s have a look at the sleep_total_h variable: #print(afl.margins) print(mammalian_sleep$sleep_total_h) ## [1] 12 17 14 15 4 14 9 7 10 3 5 9 10 12 10 8 9 17 5 18 4 20 3 3 10 ## [26] 11 15 12 10 2 3 6 6 8 10 3 19 10 14 14 13 12 20 15 11 8 14 8 4 10 ## [51] 16 10 14 9 10 11 12 14 4 6 11 18 5 13 9 10 8 11 11 17 14 16 13 9 9 ## [76] 16 4 16 9 5 6 12 10 This output doesn’t make it easy to get a sense of what the data are actually saying. Just “looking at the data” isn’t a terribly effective way of understanding data. In order to get some idea about what’s going on, we need to calculate some descriptive statistics and draw some nice pictures. Let’s take a look at a histogram of these data: A histogram is a graphical representation of the frequencies of different values of ranges of values in the data. mammalian_sleep %&gt;% ggplot(aes(sleep_total_h)) + geom_histogram(binwidth = 1, color = &quot;black&quot;, fill = &quot;lightgrey&quot;) Figure 3.1: A histogram of the average amount of sleep by animal (the sleep_total_h variable). As you might expect, the larger the margin the less frequently you tend to see it. 3.1 Measures of central tendency Drawing pictures of the data, as I did in Figure 3.1 is an excellent way to convey the “gist” of what the data is trying to tell you, it’s often extremely useful to try to condense the data into a few simple “summary” statistics. In most situations, the first thing that you’ll want to calculate is a measure of central tendency. That is, you’d like to know something about the “average” or “middle” of your data lies. The two most commonly used measures are the mean, median and mode; occasionally people will also report a trimmed mean. I’ll explain each of these in turn, and then discuss when each of them is useful. 3.1.1 The mean The mean of a set of observations is just a normal, old-fashioned average: add all of the values up, and then divide by the total number of values. The first five animals’ typical amount of sleep is 12 + 17 + 14 + 15 + 4, so the mean of these observations is just: \\[ \\frac{12 + 17 + 14 + 15 + 4}{5} = \\frac{62.4}{5} = 12.48 \\] Of course, this definition of the mean isn’t news to anyone: averages (i.e., means) are used so often in everyday life that this is pretty familiar stuff. However, since the concept of a mean is something that everyone already understands, I’ll use this as an excuse to start introducing some of the mathematical notation that statisticians use to describe this calculation, and talk about how the calculations would be done in R. The first piece of notation to introduce is \\(N\\), which we’ll use to refer to the number of observations that we’re averaging (in this case \\(N = 5\\)). Next, we need to attach a label to the observations themselves. It’s traditional to use \\(X\\) for this, and to use subscripts to indicate which observation we’re actually talking about. That is, we’ll use \\(X_1\\) to refer to the first observation, \\(X_2\\) to refer to the second observation, and so on, all the way up to \\(X_N\\) for the last one. Or, to say the same thing in a slightly more abstract way, we use \\(X_i\\) to refer to the \\(i\\)-th observation. Just to make sure we’re clear on the notation, the following table lists the 5 observations in the sleep_total_h variable, along with the mathematical symbol used to refer to it, and the actual value that the observation corresponds to: the observation its symbol the observed value Cheetah (animal 1) \\(X_1\\) 12 hours Owl monkey (animal 2) \\(X_2\\) 17 hours Mountain beaver (animal 3) \\(X_3\\) 14 hours Greater short-tailed shrew (animal 4) \\(X_4\\) 15 hours Cow (animal 5) \\(X_5\\) 4 hours Okay, now let’s try to write a formula for the mean. By tradition, we use \\(\\bar{X}\\) as the notation for the mean. So the calculation for the mean could be expressed using the following formula: \\[ \\bar{X} = \\frac{X_1 + X_2 + ... + X_{N-1} + X_N}{N} \\] This formula is entirely correct, but it’s terribly long, so we make use of the summation symbol \\(\\scriptstyle\\sum\\) to shorten it.1 If I want to add up the first five observations, I could write out the sum the long way, \\(X_1 + X_2 + X_3 + X_4 +X_5\\) or I could use the summation symbol to shorten it to this: \\[ \\sum_{i=1}^5 X_i \\] Taken literally, this could be read as “the sum, taken over all \\(i\\) values from 1 to 5, of the value \\(X_i\\)”. But basically, what it means is “add up the first five observations”. In any case, we can use this notation to write out the formula for the mean, which looks like this: \\[ \\bar{X} = \\frac{1}{N} \\sum_{i=1}^N X_i \\] In all honesty, I can’t imagine that all this mathematical notation helps clarify the concept of the mean at all. In fact, it’s really just a fancy way of writing out the same thing I said in words: add all the values up, and then divide by the total number of items. However, that’s not really the reason I went into all that detail. My goal was to try to make sure that everyone reading this book is clear on the notation that we’ll be using throughout the book: \\(\\bar{X}\\) for the mean, \\(\\scriptstyle\\sum\\) for the idea of summation, \\(X_i\\) for the \\(i\\)th observation, and \\(N\\) for the total number of observations. We’re going to be re-using these symbols a fair bit, so it’s important that you understand them well enough to be able to “read” the equations, and to be able to see that it’s just saying “add up lots of things and then divide by another thing”. 3.1.2 Calculating the mean in R Okay that’s the maths, how do we get the magic computing box to do the work for us? If you really wanted to, you could do this calculation directly in R. For the first numbers, do this just by typing it in as if R were a calculator… (12 + 17 + 14 + 15 + 4) / 5 ## [1] 12.4 … in which case R outputs the answer 36.6, just as if it were a calculator. However, we learned quicker ways of doing that sum( mammalian_sleep$sleep_total_h[1:5] )/ 5 ## [1] 12.4 # or: mean( mammalian_sleep$sleep_total_h[1:5] ) ## [1] 12.4 3.1.3 The median The second measure of central tendency that people use a lot is the median, and it’s even easier to describe than the mean. The median of a set of observations is just the middle value. As before let’s imagine we were interested only in the first 5 animals: They sleep 12, 17, 14, 15, and 4 hours respectively. To figure out the median, we sort these numbers into ascending order: \\[ 4, 12, \\color{red}{14}, 15, 17 \\] From inspection, it’s obvious that the median value of these 5 observations is 32, since that’s the middle one in the sorted list (I’ve put it in red to make it even more obvious). Easy stuff. But what should we do if we were interested in the first 6 animals rather than the first 5? Since the sixth animal sleeps for 14 hours, our sorted list is now: \\[ 4, 12, \\color{red}{14}, \\color{red}{14}, 15, 17 \\] That’s also easy. It’s still 14. But what we do if we were interested in the first 8 animals? Here is our new sorted list. \\[ 4, 7, 9, \\color{red}{12}, \\color{red}{14}, 14, 15, 17 \\] There are now two middle numbers, 12 and 14. The median is defined as the average of those two numbers, which is of course 13. To understand why, think of the median as the value that divides the sorted list of numbers into two halves – those on its left, and those on its right. As before, it’s very tedious to do this by hand when you’ve got lots of numbers. To illustrate this, here’s what happens when you use R to sort all the sleep durations. First, I’ll use the sort() function to display the 83 numbers in increasing numerical order: sort( mammalian_sleep$sleep_total_h ) ## [1] 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 6 6 6 6 7 8 8 8 8 8 ## [26] 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 ## [51] 11 12 12 12 12 12 12 13 13 13 14 14 14 14 14 14 14 14 15 15 15 16 16 16 16 ## [76] 17 17 17 18 18 19 20 20 Because the vector is 83 elements long, the middle value is at position 42. This means that the median of this vector is 10. In real life, of course, no-one actually calculates the median by sorting the data and then looking for the middle value. In real life, we use the median command: median( mammalian_sleep$sleep_total_h ) ## [1] 10 which outputs the median value of 10. 3.1.4 Mean or median? What’s the difference? Figure 3.2: An illustration of the difference between how the mean and the median should be interpreted. The mean is basically the “centre of gravity” of the data set: if you imagine that the histogram of the data is a solid object, then the point on which you could balance it (as if on a see-saw) is the mean. In contrast, the median is the middle observation. Half of the observations are smaller, and half of the observations are larger. Knowing how to calculate means and medians is only a part of the story. You also need to understand what each one is saying about the data, and what that implies for when you should use each one. This is illustrated in Figure 3.2 the mean is kind of like the “centre of gravity” of the data set, whereas the median is the “middle value” in the data. What this implies, as far as which one you should use, depends a little on what type of data you’ve got and what you’re trying to achieve. As a rough guide: One consequence is that there’s systematic differences between the mean and the median when the histogram is asymmetric (skewed; see Section ??). This is illustrated in Figure 3.2 notice that the median (right hand side) is located closer to the “body” of the histogram, whereas the mean (left hand side) gets dragged towards the “tail” (where the extreme values are). To give a concrete example, suppose Bob (income $50,000), Kate (income $60,000) and Jane (income $65,000) are sitting at a table: the average income at the table is $58,333 and the median income is $60,000. Then Bill sits down with them (income $100,000,000). The average income has now jumped to $25,043,750 but the median rises only to $62,500. If you’re interested in looking at the overall income at the table, the mean might be the right answer; but if you’re interested in what counts as a typical income at the table, the median would be a better choice here. 3.1.5 Trimmed mean One of the fundamental rules of applied statistics is that the data are messy. Real life is never simple, and so the data sets that you obtain are never as straightforward as the statistical theory says.2 This can have awkward consequences. To illustrate, consider this rather strange looking data set (nevermind what it represents): \\[ -100,2,3,4,5,6,7,8,9,10 \\] If you were to observe this in a real life data set, you’d probably suspect that something funny was going on with the \\(-100\\) value. It’s probably an outlier, a value that doesn’t really belong with the others. You might consider removing it from the data set entirely, and in this particular case I’d probably agree with that course of action. In real life, however, you don’t always get such cut-and-dried examples. For instance, you might get this instead: \\[ -15,2,3,4,5,6,7,8,9,12 \\] The \\(-15\\) looks a bit suspicious, but not anywhere near as much as that \\(-100\\) did. In this case, it’s a little trickier. It might be a legitimate observation, it might not. When faced with a situation where some of the most extreme-valued observations might not be quite trustworthy, the mean is not necessarily a good measure of central tendency. It is highly sensitive to one or two extreme values, and is thus not considered to be a robust measure. One remedy that we’ve seen is to use the median. A more general solution is to use a “trimmed mean”. To calculate a trimmed mean, what you do is “discard” the most extreme examples on both ends (i.e., the largest and the smallest), and then take the mean of everything else. The goal is to preserve the best characteristics of the mean and the median: just like a median, you aren’t highly influenced by extreme outliers, but … like the mean, you “use” more than one of the observations. Generally, we describe a trimmed mean in terms of the percentage of observation on either side that are discarded. So, for instance, a 10% trimmed mean discards the largest 10% of the observations and the smallest 10% of the observations, and then takes the mean of the remaining 80% of the observations. Not surprisingly, the 0% trimmed mean is just the regular mean, and the 50% trimmed mean is the median. In that sense, trimmed means provide a whole family of central tendency measures that span the range from the mean to the median. For our toy example above, we have 10 observations, and so a 10% trimmed mean is calculated by ignoring the largest value (i.e., 12) and the smallest value (i.e., -15) and taking the mean of the remaining values. First, let’s enter the data dataset &lt;- c( -15,2,3,4,5,6,7,8,9,12 ) Next, let’s calculate means and medians: mean( dataset ) ## [1] 4.1 median( dataset ) ## [1] 5.5 That’s a fairly substantial difference, but I’m tempted to think that the mean is being influenced a bit too much by the extreme values at either end of the data set, especially the \\(-15\\) one. So let’s just try trimming the mean a bit. If I take a 10% trimmed mean, we’ll drop the extreme values on either side, and take the mean of the rest: mean( dataset, trim = .1) ## [1] 5.5 In this case it gives exactly the same answer as the median. Note that, to get a 10% trimmed mean you write trim = .1, not trim = 10. 3.1.6 Mode The mode is the last measure of central tendency we’ll look at. It is very simple: it is the value that occurs most frequently. Let’s look at the some soccer data: specifically, the European Cup and Champions League results in the time from 1955-2016. Lets find out which team has won the most matches. The command below tells R we just want the first 25 rows of the data.frame. library(engsoccerdata) table(champs$tiewinner) %&gt;% sort(decreasing=T) %&gt;% .[1:25] ## ## Real Madrid Bayern Munich SL Benfica AC Milan ## 183 134 110 103 ## Barcelona Liverpool Juventus Dinamo Kiev ## 101 97 87 82 ## Celtic Manchester United RSC Anderlecht AFC Ajax ## 81 81 75 71 ## Internazionale Steaua Bucuresti Crvena Zvezda Rangers ## 66 63 61 58 ## Partizan Belgrade PSV Eindhoven Dinamo Zagreb FC Porto ## 52 49 48 46 ## Atletico Madrid Panathinaikos BATE Borisov CSKA Sofia ## 45 44 40 40 ## Galatasaray ## 40 It appears that the mode of the winning team is ‘Real Madrid’. That doesn’t come as a surprise even to me. Of course, the mode is the right (and only) summary for nominal variables. But we can compute a mode for all types of variables. For example, let’s take a look at the mean, median, and mode of the total number of goals per game. champs %&lt;&gt;% mutate(total_goals = hgoal + vgoal) # total goals is home team goals + visitor goals mean(champs$total_goals) ## [1] 2.81642 median(champs$total_goals) ## [1] 3 modeOf(champs$total_goals) ## [1] 2 ggplot(champs, aes(total_goals)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.2 Summary There are multiple measures of central tendency that can be used to summarize an aspect of a distribution: _ (arithmetic) mean, median, and mode_. They answer different questions about distribution. For example, in the distribution of number of goals per game in the previous section mean: “If the same number of goals were scored in each game, how many goals would be scored?” median: “What is a ‘mediocre’ game like?” mode: “What is the most typical game like?” 3.3 Measures of variability The statistics that we’ve discussed so far all relate to central tendency. That is, they all talk about which values are “in the middle” or “popular” in the data. The second thing that we really want is a measure of the variability of the data. That is, how “spread out” are the data? In other words, how ‘representative’ is our measure of central tendency of most data points. Let’s consider interval and ratio scale data. 3.3.1 Range The range of a variable is very simple: it’s the biggest value minus the smallest value. For the sleep data, the maximum value is 20, and the minimum value is 2. We can calculate these values in R using the max() and min() functions: max( mammalian_sleep$sleep_total_h ) ## [1] 20 min( mammalian_sleep$sleep_total_h ) ## [1] 2 where I’ve omitted the output because it’s not interesting. The other possibility is to use the range() function; which outputs both the minimum value and the maximum value in a vector, like this: range( mammalian_sleep$sleep_total_h ) ## [1] 2 20 Although the range is the simplest way to quantify the notion of “variability”, it’s one of the worst. Recall from our discussion of the mean that we want our summary measure to be robust. If the data set has one or two extremely bad values in it, we’d like our statistics not to be unduly influenced by these cases. If we look once again at our toy example of a data set containing very extreme outliers… \\[ -100,2,3,4,5,6,7,8,9,10 \\] … it is clear that the range is not robust, since this has a range of 110, but if the outlier were removed we would have a range of only 8. 3.3.2 Quantiles and percentile A key concept we will need to build on to conceptualize several other measures of variability are quantiles or percentiles. A percentile is the smallest value in a dataset such that a set percentage is smaller than it. (A quantile does pretty much the same but is more generic.) For example, if the 10-th percentile (i.e., the \\(0.1\\) quantile) of a list of values is 73, this means that 10 percent of the values are smaller than or equal to 73. Let’s take a look at the 20 shortest sorted sleep durations and determine the 10-th percentile (\\(0.1\\) quantile), 30-th percentile (\\(0.3\\) quantile), 50-th percentile (\\(0.5\\) quantile), and the 90-th percentile (\\(0.9\\) quantile). Here are the values: sort(mammalian_sleep$sleep_total_h)[1:20] ## [1] 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 6 6 6 6 7 And here is a sorted plot: quantile &lt;- c(0.1,0.3,0.5,0.9) quantile_points &lt;- c(0.1,0.3,0.5,0.9)*20 quantile_labels &lt;- sprintf(&quot;%0.1f quantile\\n(point %d of 20)&quot;, quantile, quantile_points) ggplot(data=NULL, aes(x=1:20, y=sort(mammalian_sleep$sleep_total_h)[1:20])) + geom_point() + geom_vline(xintercept = quantile_points) + geom_label(aes(x=quantile_points, y=6.5, label=quantile_labels )) As you can see: 10-th percentile (\\(0.1\\) quantile): 3 30-th percentile (\\(0.3\\) quantile): 3 50-th percentile (\\(0.5\\) quantile): 4 90-th percentile (\\(0.9\\) quantile): 6 The 50-th percentile is the median. 3.3.3 Interquartile range The interquartile range (IQR) is like the range, but instead of calculating the difference between the biggest and smallest value, it calculates the difference between the 25th quantile and the 75th quantile. R provides you with a way of calculating quantiles, using the (surprise, surprise) quantile() function. Let’s use it to calculate the median sleep durations: quantile( x = mammalian_sleep$sleep_total_h, probs = .5) ## 50% ## 10 And not surprisingly, this agrees with the answer that we saw earlier with the median() function. Now, we can actually input lots of quantiles at once, by specifying a vector for the probs argument. So lets do that, and get the 25th and 75th percentile: quantile( x = mammalian_sleep$sleep_total_h, probs = c(.25,.75) ) ## 25% 75% ## 8 14 And, by noting that \\(14 - 8 = 6\\), we can see that the interquartile range for the sleep durations is 6. Of course, that seems like too much work to do all that typing, so R has a built in function called IQR() that we can use: IQR( x = mammalian_sleep$sleep_total_h ) ## [1] 6 While it’s obvious how to interpret the range, it’s a little less obvious how to interpret the IQR. The simplest way to think about it is like this: the interquartile range is the range spanned by the “middle half” of the data. That is, one quarter of the data falls below the 25th percentile, one quarter of the data is above the 75th percentile, leaving the “middle half” of the data lying in between the two. And the IQR is the range covered by that middle half. 3.3.4 Mean absolute deviation The range and the interquartile range, both rely on the idea that we can measure the spread of the data by looking at the quantiles of the data. However, this isn’t the only way to think about the problem. A different approach is to select a meaningful reference point (usually the mean or the median) and then report the “typical” deviations from that reference point. Let’s go through the mean absolute deviation (AAD for average absolute deviation, since MAD is reserved for the median absolute deviation) from the mean a little more slowly. One useful thing about this measure is that the name actually tells you exactly how to calculate it: \\[ AAD(X) = \\frac{1}{N} \\sum_{i = 1}^N |X_i - \\bar{X}| \\] Let’s compute the AAD for the first data points in the sleep data: \\[ 12, 17, 14, 15, 4 \\] The mean of the dataset is 12.4. That is, \\(\\bar{X} = 12.4\\) The deviations \\(X_i - \\bar{X}\\) are: \\[ -0.4, 4.6, 1.6, 2.6, -8.4 \\] The absolute deviations \\(|X_i - \\bar{X}|\\) are: \\[ 0.4, 4.6, 1.6, 2.6, 8.4 \\] The sum of the absolute deviations \\(\\sum_{i = 1}^N |X_i - \\bar{X}|\\) is 17.6. \\[ 0.4, 4.6, 1.6, 2.6, 8.4 \\] And \\(N=5\\), which means, that \\(AAD(X) = \\frac{1}{N} \\sum_{i = 1}^N |X_i - \\bar{X}| = 3.52\\), in our case. In R, we can compute it for the entire vector. mean_sleep &lt;- mean(mammalian_sleep$sleep_total_h) dev_sleep &lt;- mean_sleep - mammalian_sleep$sleep_total_h mean( abs(dev_sleep) ) ## [1] 3.576717 The interpretation of the AAD is quite straightforward: It is the average distance from the average. When it’s big, the values are quite spread out. When it’s small, they are close. The units are the same (hours in our case). 3.3.5 Variance Although the mean absolute deviation measure has its uses, it’s not the best measure of variability to use. From a purely mathematical perspective, there are some solid reasons to prefer squared deviations rather than absolute deviations. If we do that, we obtain a measure is called the variance, which has a lot of really nice statistical properties that I’m going to ignore,3(X)$ and \\(\\mbox{Var}(Y)\\) respectively. Now imagine I want to define a new variable \\(Z\\) that is the sum of the two, \\(Z = X+Y\\). As it turns out, the variance of \\(Z\\) is equal to \\(\\mbox{Var}(X) + \\mbox{Var}(Y)\\). This is a very useful property, but it’s not true of the other measures that I talk about in this section.] and one massive psychological flaw that I’m going to make a big deal out of in a moment. The variance of a data set \\(X\\) is sometimes written as \\(\\mbox{Var}(X)\\), but it’s more commonly denoted \\(s^2\\) (the reason for this will become clearer shortly). The formula that we use to calculate the variance of a set of observations is as follows: \\[ \\mbox{Var}(X) = \\frac{1}{N} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2 \\] \\[\\mbox{Var}(X) = \\frac{\\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2}{N}\\] As you can see, it’s basically the same formula that we used to calculate the mean absolute deviation, except that instead of using “absolute deviations” we use “squared deviations”. It is for this reason that the variance is sometimes referred to as the “mean square deviation”. Now that we’ve got the basic idea, let’s have a look at a concrete example. Once again, let’s use the first five AFL games as our data. If we follow the same approach that we took last time, we end up with the following table: Table 3.1: Regular, abssolute, and squared deviations Notation [English] \\(i\\) [animal] \\(X_i\\) [value] \\(X_i - \\bar{X}\\) [deviation from mean] \\(&amp;#124;X_i - \\bar{X}&amp;#124;\\) [absolute deviation from mean] \\((X_i - \\bar{X})^2\\) [absolute deviation] 1 12 -0.4 0.4 0.16 2 17 4.6 4.6 21.16 3 14 1.6 1.6 2.56 4 15 2.6 2.6 6.76 5 4 -8.4 8.4 70.56 That last column contains all of our squared deviations, so all we have to do is average them. If we do that by typing all the numbers into R by hand… ( 0.16+21.16+2.56+6.76+70.56 ) / 5 ## [1] 20.24 … we end up with a variance of 20.24. Exciting, isn’t it? For the moment, let’s ignore the burning question that you’re all probably thinking (i.e., what the heck does a variance of 20.24 actually mean?) and instead talk a bit more about how to do the calculations in R, because this will reveal something very weird. As always, we want to avoid having to type in a whole lot of numbers ourselves. And as it happens, we have the vector X lying around, which we created in the previous section. With this in mind, we can calculate the variance of X by using the following command, X &lt;- mammalian_sleep$sleep_total_h[1:5] mean( (X - mean(X) )^2) ## [1] 20.24 and as usual we get the same answer as the one that we got when we did everything by hand. However, I still think that this is too much typing. Fortunately, R has a built in function called var() which does calculate variances. So we could also do this… var(X) ## [1] 25.3 and you get the same… no, wait… you get a completely different answer. That’s just weird. Is R broken? As it happens, the answer is no. It’s not a typo, and R is not making a mistake. To get a feel for what’s happening, let’s stop using the tiny data set containing only 5 data points, and switch to the full set of data points we’ve got stored in our mammalian_sleep$sleep_total_h vector. First, let’s calculate the variance by using the formula that I described above: X &lt;- mammalian_sleep$sleep_total_h mean( (X - mean(X) )^2) ## [1] 19.71171 Now let’s use the var() function: var( X ) ## [1] 19.9521 Hm. These two numbers are very similar this time. That seems like too much of a coincidence to be a mistake. And of course it isn’t a mistake. In fact, it’s very simple to explain what R is doing here, but slightly trickier to explain why R is doing it. So let’s start with the “what”. What R is doing is evaluating a slightly different formula to the one I showed you above. Instead of averaging the squared deviations, which requires you to divide by the number of data points \\(N\\), R has chosen to divide by \\(N-1\\). In other words, the formula that R is using is this one \\[ \\frac{1}{N-1} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2 \\] It’s easy enough to verify that this is what’s happening, as the following command illustrates: X &lt;- mammalian_sleep$sleep_total_h[1:5] sum( (X-mean(X))^2 ) / 4 ## [1] 25.3 This is the same answer that R gave us originally when we calculated var(X) originally. So that’s the what. The real question is why R is dividing by \\(N-1\\) and not by \\(N\\). After all, the variance is supposed to be the mean squared deviation, right? So shouldn’t we be dividing by \\(N\\), the actual number of observations in the sample? Well, yes, we should. However, there’s a subtle distinction between “describing a sample” and “making guesses about the population from which the sample came”. Up to this point, it’s been a distinction without a difference. Regardless of whether you’re describing a sample or drawing inferences about the population, the mean is calculated exactly the same way. Not so for the variance, or the standard deviation, or for many other measures besides. What I outlined to you initially (i.e., take the actual average, and thus divide by \\(N\\)) assumes that you literally intend to calculate the variance of the sample. Most of the time, however, you’re not terribly interested in the sample in and of itself. Rather, the sample exists to tell you something about the world. If so, you’re actually starting to move away from calculating a “sample statistic”, and towards the idea of estimating a “population parameter”. 3.3.6 Standard deviation One problem with the variance is that it is expressed in odd units. In the case above it’s \\(h^2\\) (hours squared). I know what \\(m^2\\), but what are \\(h^2\\)? No idea. Suppose that you’d like to have a measure that is expressed in the same units as the data itself (i.e., points, not points-squared). What should you do? The solution to the problem is obvious: take the square root of the variance, known as the standard deviation, also called the “root mean squared deviation”, or RMSD. This solves out problem fairly neatly. While nobody has a clue what “a variance of 19.95 hours-squared” really means, it’s much easier to understand “a standard deviation of 4.5 hours”, since it’s expressed in the original units. It is traditional to refer to the standard deviation of a sample of data as \\(s\\), though “sd” and “std dev.” are also used at times. Because the standard deviation is equal to the square root of the variance, you probably won’t be surprised to see that the formula is: \\[ s = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2 } \\] and the R function that we use to calculate it is sd(). However, as you might have guessed from our discussion of the variance, what R actually calculates is slightly different to the formula given above. Just like the we saw with the variance, what R calculates is a version that divides by \\(N-1\\) rather than \\(N\\). \\[ \\hat\\sigma = \\sqrt{ \\frac{1}{N-1} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2 } \\] With that in mind, calculating standard deviations in R is simple: sd( mammalian_sleep$sleep_total_h ) ## [1] 4.466777 Interpreting standard deviations is slightly more complex. Because the standard deviation is derived from the variance, and the variance is a quantity that has little to no meaning that makes sense to us humans, the standard deviation doesn’t have a simple interpretation. As a consequence, most of us just rely on a simple rule of thumb: in general, you should expect 68% of the data to fall within 1 standard deviation of the mean, 95% of the data to fall within 2 standard deviation of the mean, and 99.7% of the data to fall within 3 standard deviations of the mean. This rule tends to work pretty well most of the time, but it’s not exact: it’s actually calculated based on an assumption that the histogram is symmetric and “bell shaped”. (Strictly, the assumption is that the data are normally distributed, which is an important concept that we’ll discuss more later). ## [1] 0.6385542 3.3.7 Which measure to use? We’ve discussed quite a few measures of spread (range, IQR, AAD, variance and standard deviation), and hinted at their strengths and weaknesses. Here’s a quick summary: Range. Gives you the full spread of the data. It’s very vulnerable to outliers, and as a consequence it isn’t often used unless you have good reasons to care about the extremes in the data. Interquartile range. Tells you where the “middle half” of the data sits. It’s pretty robust, and complements the median nicely. This is used a lot. Mean absolute deviation. Tells you how far “on average” the observations are from the mean. It’s very interpretable, but has a few minor issues (not discussed here) that make it less attractive to statisticians than the standard deviation. Used sometimes, but not often. Variance. Tells you the average squared deviation from the mean. It’s mathematically elegant, and is probably the “right” way to describe variation around the mean, but it’s completely uninterpretable because it doesn’t use the same units as the data. Almost never used except as a mathematical tool; but it’s buried “under the hood” of a very large number of statistical tools. Standard deviation. This is the square root of the variance. It’s fairly elegant mathematically, and it’s expressed in the same units as the data so it can be interpreted pretty well. In situations where the mean is the measure of central tendency, this is the default. This is by far the most popular measure of variation. In short, the IQR and the standard deviation are easily the two most common measures used to report the variability of the data; but there are situations in which the others are used. I’ve described all of them in this book because there’s a fair chance you’ll run into most of these somewhere. The choice to use \\(\\Sigma\\) to denote summation isn’t arbitrary: it’s the Greek upper case letter sigma, which is the analogue of the letter S in that alphabet. Similarly, there’s an equivalent symbol used to denote the multiplication of lots of numbers: because multiplications are also called “products”, we use the \\(\\Pi\\) symbol for this; the Greek upper case pi, which is the analogue of the letter P.↩ Or at least, the basic statistical theory – these days there is a whole subfield of statistics called robust statistics that tries to grapple with the messiness of real data and develop theory that can cope with it.↩ Well, I will very briefly mention the one that I think is coolest, for a very particular definition of “cool”, that is. Variances are additive. Here’s what that means: suppose I have two variables \\(X\\) and \\(Y\\), whose variances are $↩ "]]
